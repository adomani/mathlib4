/-
Copyright (c) 2025 Yaël Dillies, Patrick Luo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies, Patrick Luo
-/
import Mathlib.Algebra.Group.Irreducible.Defs
import Mathlib.Algebra.Group.Submonoid.BigOperators
import Mathlib.GroupTheory.Finiteness

/-!
# An affine monoid with no non-trivial unit is generated by its irreducible elements

This file proves that an additive cancellative monoid with no non-trivial unit unit is generated by
its irreducible elements.
-/

variable {M : Type*} {S : Set M}

section CommMonoid
variable [CommMonoid M] [Subsingleton Mˣ]

/-- Any set `S` contains the irreducible elements of the submonoid it generates. -/
@[to_additive "Any set `S` contains the irreducible elements of the submonoid it generates."]
lemma irreducible_mem_submonoidClosure_subset : {p ∈ Submonoid.closure S | Irreducible p} ⊆ S := by
  refine fun x hx ↦
      Submonoid.closure_induction (s := S) (motive := fun x _ ↦ (Irreducible x → x ∈ S))
      (fun _ hx _ ↦ hx) (by simp) (fun a b _ _ ha hb h ↦ ?_) hx.1 hx.2
  obtain rfl | rfl := h.eq_one_or_eq_one rfl <;> simp_all

/-- Irreducible elements lie in all sets generating a salient monoid. -/
@[to_additive "Irreducible elements lie in all sets generating a salient monoid."]
lemma irreducible_subset_of_submonoidClosure_eq_top (hS : Submonoid.closure S = ⊤) :
    {p | Irreducible p} ⊆ S := by
  simpa [hS] using irreducible_mem_submonoidClosure_subset (S := S)

/-- A finitely generated salient submonoid has finitely many irreducible elements. -/
@[to_additive "A finitely generated salient submonoid has finitely many irreducible elements."]
lemma Submonoid.FG.finite_irreducible_mem_submonoidClosure {S : Submonoid M} :
    S.FG → {p ∈ S | Irreducible p}.Finite := by
  rintro ⟨T, hT⟩; exact T.finite_toSet.subset <| hT ▸ irreducible_mem_submonoidClosure_subset

variable [Monoid.FG M]

/-- A finitely generated salient monoid has finitely many irreducible elements. -/
@[to_additive "A finitely generated salient monoid has finitely many irreducible elements."]
lemma finite_irreducible : {p : M | Irreducible p}.Finite := by
  simpa using Monoid.FG.fg_top.finite_irreducible_mem_submonoidClosure

end CommMonoid

section CancelCommMonoid
variable [CancelCommMonoid M] [Monoid.FG M] [Subsingleton Mˣ] {S : Set M}

/-- A finitely generated cancellative submonoid with a single unit is generated by
its (finitely many) irreducible elements. -/
@[to_additive (attr := simp)
"A finitely generated cancellative submonoid with a single unit is generated by
its (finitely many) irreducible elements."]
lemma Submonoid.closure_irreducible : Submonoid.closure {p : M | Irreducible p} = ⊤ := by
  classical
  obtain ⟨S, hSgen, hSmax⟩ := Submonoid.exists_minimal_closure_eq_top M
  convert hSgen
  refine (irreducible_subset_of_submonoidClosure_eq_top hSgen).antisymm fun r hrS ↦ ?_
  by_contra hrirred
  simp only [irreducible_iff, Set.mem_setOf_eq, not_and, not_forall, Classical.not_imp,
    not_or] at hrirred
  obtain rfl | hr₀ := eq_or_ne r 1
  · simpa using hSmax (y := S \ {1}) (by simpa) Finset.sdiff_subset hrS
  obtain ⟨a, b, hr, ha, hb⟩ := hrirred <| by simpa
  obtain ⟨m, -, hm⟩ := Submonoid.mem_closure_finset (x := a).mp (by rw [hSgen]; trivial)
  obtain ⟨n, -, hn⟩ := Submonoid.mem_closure_finset (x := b).mp (by rw [hSgen]; trivial)
  replace hm : a = r ^ m r * ∏ s ∈ S \ {r}, s ^ m s := by
    rw [← hm, ← Finset.prod_sdiff <| Finset.singleton_subset_iff.2 hrS, Finset.prod_singleton,
      mul_comm]
  replace hn : b = r ^ n r * ∏ s ∈ S \ {r}, s ^ n s := by
    rw [← hn, ← Finset.prod_sdiff <| Finset.singleton_subset_iff.2 hrS, Finset.prod_singleton,
      mul_comm]
  have hr' : r = r ^ (m r + n r) * (∏ s ∈ S \ {r}, s ^ m s) * ∏ s ∈ S \ {r}, s ^ n s := by
    rwa [pow_add, mul_assoc, mul_assoc, ← mul_assoc (r ^ n r), mul_comm (r ^ n r) _, mul_assoc,
      ← hn, ← mul_assoc, ← hm]
  match hr : m r + n r with
  | 0 =>
    have : ({r} : Set M) ⊆ closure (S \ {r}) := by
      simp only [hr, pow_zero, one_mul] at hr'
      rw [hr', Set.singleton_subset_iff]
      refine mul_mem ?_ ?_ <;> refine prod_mem _ fun s hs ↦ pow_mem (subset_closure ?_) _ <;>
        rw [← hr'] <;> simpa using hs
    specialize hSmax (y := S \ {r}) (by simp [this, hSgen]) Finset.sdiff_subset
    simpa using hSmax hrS
  | 1 =>
    simp only [hr, pow_one, mul_assoc, eq_comm (a := r), mul_eq_left, LeftCancelMonoid.mul_eq_one,
      Finset.prod_eq_one_iff] at hr'
    obtain h | h : m r = 0 ∨ n r = 0 := by omega
    · obtain rfl : a = 1 := by simpa [h, Finset.prod_eq_one hr'.1] using hm
      simp at ha
    · obtain rfl : b = 1 := by simpa [h, Finset.prod_eq_one hr'.2] using hn
      simp at hb
  | N + 2 =>
    simp [eq_comm (a := (1 : M)), hr, hr₀, pow_add, mul_assoc, mul_left_comm] at hr'

end CancelCommMonoid
